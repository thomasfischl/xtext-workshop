/*
 * generated by Xtext
 */
package com.github.thomasfischl.minipascal.generator

import com.github.thomasfischl.minipascal.pascal.Expr
import com.github.thomasfischl.minipascal.pascal.ExprExt
import com.github.thomasfischl.minipascal.pascal.Fact
import com.github.thomasfischl.minipascal.pascal.Model
import com.github.thomasfischl.minipascal.pascal.Stat
import com.github.thomasfischl.minipascal.pascal.Term
import com.github.thomasfischl.minipascal.pascal.TermExt
import com.github.thomasfischl.minipascal.pascal.VarName
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IFileSystemAccess
import org.eclipse.xtext.generator.IGenerator

/**
 * Generates code from your model files on save.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#TutorialCodeGeneration
 */
	class PascalGenerator implements IGenerator {
	
		override void doGenerate(Resource resource, IFileSystemAccess fsa) {
			for (e : resource.allContents.toIterable.filter(Model)) {
				fsa.generateFile(e.program + ".java", e.compile)
			}
		}
	
		def CharSequence compile(Model model) ''' 
		import java.io.BufferedReader;
		import java.io.IOException;
		import java.io.InputStreamReader;
		
		public class «model.program» {
			public static void main(String[] args) throws IOException {
				
				try (BufferedReader reader = new BufferedReader(new InputStreamReader(System.in))) {
					«IF model?.vardecls != null»
						«FOR vardecl : model?.vardecls?.vars»
							«vardecl.compile»
						«ENDFOR»
					«ENDIF»
			
					«FOR stat : model.statseq?.stats»
						«stat.compile»
					«ENDFOR»
				}
			}
		}
	'''

	def CharSequence compile(VarName varName) ''' 
		int «varName.name»;
	'''

	def CharSequence compile(Stat stat) ''' 
		«IF stat.write != null»
			System.out.println(String.valueOf(«stat.write.compile»));
		«ELSEIF stat.read != null»
			«stat.read» = Integer.valueOf(reader.readLine());
		«ELSEIF stat.leftside != null»
			«stat.leftside» = «stat.expr.compile»;
		«ENDIF»
	'''

	// Xtext Grammar
	//
	// Expr: term=Term (terms+=ExprExt)*;
	// ExprExt: (opt="+" | opt="-") term=Term ;	
	// Term: fact=Fact (facts+=TermExt)*;
	// TermExt: (opt="*" | opt="/") fact=Fact;
	// Fact: var=IDENT | number=NUMBER | "(" expr=Expr ")";
	
	def CharSequence compile(Expr expr) ''' 
	  //TODO implement
	'''

}
