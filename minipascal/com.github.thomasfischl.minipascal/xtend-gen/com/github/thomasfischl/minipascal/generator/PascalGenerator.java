/**
 * generated by Xtext
 */
package com.github.thomasfischl.minipascal.generator;

import com.github.thomasfischl.minipascal.pascal.Expr;
import com.github.thomasfischl.minipascal.pascal.ExprExt;
import com.github.thomasfischl.minipascal.pascal.Fact;
import com.github.thomasfischl.minipascal.pascal.Model;
import com.github.thomasfischl.minipascal.pascal.Stat;
import com.github.thomasfischl.minipascal.pascal.StatSeq;
import com.github.thomasfischl.minipascal.pascal.Term;
import com.github.thomasfischl.minipascal.pascal.TermExt;
import com.github.thomasfischl.minipascal.pascal.VarDecl;
import com.github.thomasfischl.minipascal.pascal.VarName;
import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.TreeIterator;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.generator.IFileSystemAccess;
import org.eclipse.xtext.generator.IGenerator;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;

/**
 * Generates code from your model files on save.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#TutorialCodeGeneration
 */
@SuppressWarnings("all")
public class PascalGenerator implements IGenerator {
  public void doGenerate(final Resource resource, final IFileSystemAccess fsa) {
    TreeIterator<EObject> _allContents = resource.getAllContents();
    Iterable<EObject> _iterable = IteratorExtensions.<EObject>toIterable(_allContents);
    Iterable<Model> _filter = Iterables.<Model>filter(_iterable, Model.class);
    for (final Model e : _filter) {
      String _program = e.getProgram();
      String _plus = (_program + ".java");
      CharSequence _compile = this.compile(e);
      fsa.generateFile(_plus, _compile);
    }
  }
  
  public CharSequence compile(final Model model) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("import java.io.BufferedReader;");
    _builder.newLine();
    _builder.append("import java.io.IOException;");
    _builder.newLine();
    _builder.append("import java.io.InputStreamReader;");
    _builder.newLine();
    _builder.newLine();
    _builder.append("public class ");
    String _program = model.getProgram();
    _builder.append(_program, "");
    _builder.append(" {");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("public static void main(String[] args) throws IOException {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("try (BufferedReader reader = new BufferedReader(new InputStreamReader(System.in))) {");
    _builder.newLine();
    {
      VarDecl _vardecls = null;
      if (model!=null) {
        _vardecls=model.getVardecls();
      }
      boolean _notEquals = (!Objects.equal(_vardecls, null));
      if (_notEquals) {
        {
          VarDecl _vardecls_1 = null;
          if (model!=null) {
            _vardecls_1=model.getVardecls();
          }
          EList<VarName> _vars = null;
          if (_vardecls_1!=null) {
            _vars=_vardecls_1.getVars();
          }
          for(final VarName vardecl : _vars) {
            _builder.append("\t\t\t");
            CharSequence _compile = this.compile(vardecl);
            _builder.append(_compile, "			");
            _builder.newLineIfNotEmpty();
          }
        }
      }
    }
    _builder.append("\t");
    _builder.newLine();
    {
      StatSeq _statseq = model.getStatseq();
      EList<Stat> _stats = null;
      if (_statseq!=null) {
        _stats=_statseq.getStats();
      }
      for(final Stat stat : _stats) {
        _builder.append("\t\t\t");
        CharSequence _compile_1 = this.compile(stat);
        _builder.append(_compile_1, "			");
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence compile(final VarName varName) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("int ");
    String _name = varName.getName();
    _builder.append(_name, "");
    _builder.append(";");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  public CharSequence compile(final Stat stat) {
    StringConcatenation _builder = new StringConcatenation();
    {
      Expr _write = stat.getWrite();
      boolean _notEquals = (!Objects.equal(_write, null));
      if (_notEquals) {
        _builder.append("System.out.println(String.valueOf(");
        Expr _write_1 = stat.getWrite();
        CharSequence _compile = this.compile(_write_1);
        _builder.append(_compile, "");
        _builder.append("));");
        _builder.newLineIfNotEmpty();
      } else {
        String _read = stat.getRead();
        boolean _notEquals_1 = (!Objects.equal(_read, null));
        if (_notEquals_1) {
          String _read_1 = stat.getRead();
          _builder.append(_read_1, "");
          _builder.append(" = Integer.valueOf(reader.readLine());");
          _builder.newLineIfNotEmpty();
        } else {
          String _leftside = stat.getLeftside();
          boolean _notEquals_2 = (!Objects.equal(_leftside, null));
          if (_notEquals_2) {
            String _leftside_1 = stat.getLeftside();
            _builder.append(_leftside_1, "");
            _builder.append(" = ");
            Expr _expr = stat.getExpr();
            CharSequence _compile_1 = this.compile(_expr);
            _builder.append(_compile_1, "");
            _builder.append(";");
            _builder.newLineIfNotEmpty();
          }
        }
      }
    }
    return _builder;
  }
  
  public CharSequence compile(final Expr expr) {
    StringConcatenation _builder = new StringConcatenation();
    Term _term = expr.getTerm();
    CharSequence _compile = this.compile(_term);
    _builder.append(_compile, "");
    _builder.newLineIfNotEmpty();
    {
      EList<ExprExt> _terms = null;
      if (expr!=null) {
        _terms=expr.getTerms();
      }
      for(final ExprExt term : _terms) {
        CharSequence _compile_1 = this.compile(term);
        _builder.append(_compile_1, "");
        _builder.newLineIfNotEmpty();
      }
    }
    return _builder;
  }
  
  public CharSequence compile(final ExprExt expr) {
    StringConcatenation _builder = new StringConcatenation();
    String _opt = expr.getOpt();
    _builder.append(_opt, "");
    _builder.append(" ");
    Term _term = expr.getTerm();
    CharSequence _compile = this.compile(_term);
    _builder.append(_compile, "");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  public CharSequence compile(final Term term) {
    StringConcatenation _builder = new StringConcatenation();
    Fact _fact = term.getFact();
    CharSequence _compile = this.compile(_fact);
    _builder.append(_compile, "");
    _builder.newLineIfNotEmpty();
    {
      EList<TermExt> _facts = null;
      if (term!=null) {
        _facts=term.getFacts();
      }
      for(final TermExt facts : _facts) {
        CharSequence _compile_1 = this.compile(facts);
        _builder.append(_compile_1, "");
        _builder.newLineIfNotEmpty();
      }
    }
    return _builder;
  }
  
  public CharSequence compile(final TermExt term) {
    StringConcatenation _builder = new StringConcatenation();
    String _opt = term.getOpt();
    _builder.append(_opt, "");
    _builder.append(" ");
    Fact _fact = term.getFact();
    CharSequence _compile = this.compile(_fact);
    _builder.append(_compile, "");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  public CharSequence compile(final Fact fact) {
    StringConcatenation _builder = new StringConcatenation();
    {
      String _var = fact.getVar();
      boolean _notEquals = (!Objects.equal(_var, null));
      if (_notEquals) {
        String _var_1 = fact.getVar();
        _builder.append(_var_1, "");
        _builder.newLineIfNotEmpty();
      } else {
        Expr _expr = fact.getExpr();
        boolean _notEquals_1 = (!Objects.equal(_expr, null));
        if (_notEquals_1) {
          Expr _expr_1 = fact.getExpr();
          CharSequence _compile = this.compile(_expr_1);
          _builder.append(_compile, "");
          _builder.newLineIfNotEmpty();
        } else {
          int _number = fact.getNumber();
          _builder.append(_number, "");
          _builder.newLineIfNotEmpty();
        }
      }
    }
    return _builder;
  }
}
