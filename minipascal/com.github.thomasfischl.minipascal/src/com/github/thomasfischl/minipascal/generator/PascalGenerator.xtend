/*
 * generated by Xtext
 */
package com.github.thomasfischl.minipascal.generator

import com.github.thomasfischl.minipascal.pascal.Expr
import com.github.thomasfischl.minipascal.pascal.ExprExt
import com.github.thomasfischl.minipascal.pascal.Fact
import com.github.thomasfischl.minipascal.pascal.Model
import com.github.thomasfischl.minipascal.pascal.Stat
import com.github.thomasfischl.minipascal.pascal.Term
import com.github.thomasfischl.minipascal.pascal.TermExt
import com.github.thomasfischl.minipascal.pascal.VarName
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IFileSystemAccess
import org.eclipse.xtext.generator.IGenerator

/**
 * Generates code from your model files on save.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#TutorialCodeGeneration
 */
class PascalGenerator implements IGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess fsa) {
		for (e : resource.allContents.toIterable.filter(Model)) {
			fsa.generateFile(e.program + ".java", e.compile)
		}
	}

	def CharSequence compile(Model model) ''' 
		import java.io.BufferedReader;
		import java.io.IOException;
		import java.io.InputStreamReader;
		
		public class «model.program» {
			public static void main(String[] args) throws IOException {
				
				BufferedReader reader = null;
				try  {
					reader = new BufferedReader(new InputStreamReader(System.in));
					«IF model?.vardecls != null»
						«FOR vardecl : model?.vardecls?.vars»
							«vardecl.compile»
						«ENDFOR»
					«ENDIF»
			
					«FOR stat : model.statseq?.stats»
						«stat.compile»
					«ENDFOR»
				} finally {
					if(reader != null) {
						reader.close();
					}
				}
			}
		}
	'''

	def CharSequence compile(VarName varName) ''' 
		int «varName.name»;
	'''

	def CharSequence compile(Stat stat) ''' 
		«IF stat.write != null»
			System.out.println(String.valueOf(«stat.write.compile»));
		«ELSEIF stat.read != null»
			«stat.read» = Integer.valueOf(reader.readLine());
		«ELSEIF stat.leftside != null»
			«stat.leftside» = «stat.expr.compile»;
		«ENDIF»
	'''

	def CharSequence compile(Expr expr) ''' 
		«expr.term.compile»
		«FOR term : expr?.terms»
			«term.compile»
		«ENDFOR»
	'''

	def CharSequence compile(ExprExt expr) ''' 
		«expr.opt» «expr.term.compile»
	'''

	def CharSequence compile(Term term) ''' 
		«term.fact.compile»
		«FOR facts : term?.facts»
			«facts.compile»
		«ENDFOR»
	'''

	def CharSequence compile(TermExt term) ''' 
		«term.opt» «term.fact.compile»
	'''

	def CharSequence compile(Fact fact) ''' 
		«IF fact.^var != null»
			«fact.^var»
		«ELSEIF fact.expr != null»
			«fact.expr.compile»
		«ELSE»
			«fact.number»
		«ENDIF»
	'''

}
